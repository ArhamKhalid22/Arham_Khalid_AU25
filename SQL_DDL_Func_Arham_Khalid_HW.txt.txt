1. What operations do the following functions perform?


→ film_in_stock(p_film_id, p_store_id, OUT p_film_count)
   Returns the number of copies of a given film that are currently IN STOCK
   (i.e. exist in inventory and are NOT currently rented out) at a specific store.


→ film_not_in_stock(p_film_id, p_store_id, OUT p_film_count)
   Returns the number of copies of a given film that are currently RENTED OUT
   (present in inventory but have an open rental with return_date IS NULL).


→ inventory_in_stock(p_inventory_id) → BOOLEAN
   Checks whether a specific inventory item (copy) is currently in stock.
   Returns TRUE if NOT rented (no open rental), FALSE otherwise.


→ get_customer_balance(p_customer_id, p_effective_date) → NUMERIC
   Calculates the total outstanding balance for a customer as of a given date.
   Currently only sums unpaid payments (status not 'Returned'). See fix below.


→ inventory_held_by_customer(p_inventory_id) → INTEGER
   Returns the customer_id who is currently renting a specific inventory item,
   or NULL if the item is in stock.


→ rewards_report(min_monthly_purchases, min_dollar_amount_earned) → SETOF record
   Intended to return customers eligible for rewards based on:
     - At least X rentals per month
     - At least Y dollars spent in total
   BUT currently returns 0 rows due to a logical bug (see fix below).


→ last_day(date) → DATE
   Simple utility: returns the last day of the month for a given date.
   Example: last_day('2025-02-10') → '2025-02-28'


2. Why does ‘rewards_report’ return 0 rows? How to fix it?


BUG: The function uses:
   WHERE count_rentals >= p_min_monthly_purchases
   AND amount_payments >= p_min_dollar_amount_earned


But in the SELECT clause, it does:
   WHERE count_rentals >= min_monthly_purchases
   AND amount_payments >= min_dollar_amount_earned


→ Uses undeclared variables → implicit comparison to NULL → always FALSE → 0 rows.


CORRECTED VERSION (without dynamic SQL):
CREATE OR REPLACE FUNCTION rewards_report(
    min_monthly_purchases INT,
    min_dollar_amount_earned NUMERIC
)
RETURNS TABLE(customer_id INT, customer_email TEXT, total_spent NUMERIC, avg_monthly_rentals NUMERIC)
LANGUAGE plpgsql AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.customer_id,
        c.email::TEXT,
        SUM(p.amount)::NUMERIC AS total_spent,
        AVG(monthly.count_rentals)::NUMERIC AS avg_monthly_rentals
    FROM customer c
    JOIN payment p ON p.customer_id = c.customer_id
    JOIN LATERAL (
        SELECT COUNT(*)::INT AS count_rentals
        FROM rental r
        WHERE r.customer_id = c.customer_id
        GROUP BY DATE_TRUNC('month', r.rental_date)
    ) monthly ON TRUE
    GROUP BY c.customer_id, c.email
    HAVING COUNT(DISTINCT DATE_TRUNC('month', p.payment_date)) >= 1
       AND SUM(p.amount) >= min_dollar_amount_earned
       AND MIN(monthly.count_rentals) >= min_monthly_purchases;
END; $$;


3. Which function can potentially be removed?


→ _group_concat(text) and group_concat(text)
   These are custom aggregate functions that mimic MySQL's GROUP_CONCAT.
   They were used in older versions of rewards_report with dynamic SQL.
   Since PostgreSQL 9.0+, string_agg(expression, delimiter) is built-in and superior.
   Both _group_concat and group_concat are obsolete and can be safely removed.


4. Fix get_customer_balance() according to its own comments


Original comment says:
-- Amount should be reduced for each returned film
-- after the rental_duration has passed. Late fee = rental_rate per day.


CURRENT CODE DOES NOT APPLY LATE FEES → only sums unpaid payments.


CORRECTED VERSION:
CREATE OR REPLACE FUNCTION get_customer_balance(
    p_customer_id INTEGER,
    p_effective_date TIMESTAMP WITH TIME ZONE
) RETURNS NUMERIC AS $$
DECLARE
    v_rentals CURSOR FOR
        SELECT
            (r.return_date IS NULL) AS open_rental,
            r.rental_date,
            f.rental_rate,
            f.rental_duration,
            COALESCE(r.return_date, p_effective_date) - r.rental_date AS days_held,
            f.rental_rate / f.rental_duration AS daily_rate
        FROM rental r
        JOIN inventory i ON i.inventory_id = r.inventory_id
        JOIN film f ON f.film_id = i.film_id
        WHERE r.customer_id = p_customer_id;
    v_balance NUMERIC := 0.0;
    v_late_days INT;
BEGIN
    -- Sum all payments
    SELECT COALESCE(SUM(amount), 0) INTO v_balance
    FROM payment
    WHERE customer_id = p_customer_id;


    -- Add late fees for overdue rentals
    FOR r IN v_rentals LOOP
        IF r.open_rental OR r.return_date > (r.rental_date + (r.rental_duration * INTERVAL '1 day')) THEN
            v_late_days := GREATEST(
                EXTRACT(DAY FROM (r.days_held - (r.rental_duration * INTERVAL '1 day')))
                , 0
            );
            v_balance := v_balance + (v_late_days * r.daily_rate);
        END IF;
    END LOOP;


    RETURN ROUND(v_balance::NUMERIC, 2);
END; $$ LANGUAGE plpgsql;


5. How do group_concat and _group_concat work?


→ _group_concat is a custom aggregate state function (SFUNC)
→ group_concat is the final aggregate that calls string_agg internally
They were created to support old dynamic SQL in rewards_report
Used only in the broken version of rewards_report
Now completely unused and redundant (use string_agg instead)


6. What does last_updated() trigger function do?


→ Automatically sets the last_update column to NOW()
  whenever a row is INSERTed or UPDATEd in tables like actor, address, category, etc.
→ Used in many BEFORE INSERT OR UPDATE triggers across the schema
→ Essential for maintaining audit timestamps


7. What is tmpSQL variable for in rewards_report?


→ It was used to build dynamic SQL string because the original author
  wanted to use variable names in WHERE clause → impossible in plain SQL
→ Then executed via EXECUTE tmpSQL
→ This is an anti-pattern in PostgreSQL


CAN IT BE REWRITTEN WITHOUT DYNAMIC SQL?
YES Using parameters directly in static SQL is safer, faster, and clearer.